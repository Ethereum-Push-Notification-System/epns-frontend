---
id: docs-chain-tutorial-build-email
title: Build Cross-Chain Email
hide_title: true
slug: ./build-email
displayed_sidebar: pushChainSidebar
sidebar_position: 1
image: "/assets/docs/previews/docs_notifications_tutorial_create_channel--creating_your_channel.png"
---

# Build a Cross-Chain Email

In this guide, we’ll demonstrate how to send a cross-chain email using the updated **Push Chain SDK**. This example shows how a user on Ethereum can send an email to their friend `ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR` on Solana.

We'll cover:
1. Setting up the SDK
2. Configuring sender and recipient addresses
3. Signing and sending a transaction
4. Fetching sent and received emails


<head>
  <title>{`Cross-Chain Email | Tutorial | Push Chain | Push Documentation`}</title>
</head>

## 1. Installing dependencies

To get started, install the required dependencies:

```shell
npm install @pushprotocol/push-chain viem
```

**Why These Libraries?**

-	`@pushprotocol/push-chain`: Core SDK for interacting with Push Chain.
-	`viem`: Utilities for Ethereum key management and signing.

Import installed dependencies:

```typescript
// Import Push Chain SDK
import { PushChain, CONSTANTS } from '@pushprotocol/push-chain';

// Import utility functions from viem
import { hexToBytes } from 'viem';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';
```

## 2. Creating the Signer Object

Let's create now the signer object that is responsible for proving ownership of the sender’s account by signing the transaction.

```typescript
const privateKey = generatePrivateKey(); // Replace with your private key
const account = privateKeyToAccount(privateKey);

const universalSigner: UniversalSigner = {
  chain: CONSTANTS.Chain.EVM.sepolia.name, // Use Sepolia testnet for this example
  chainId: CONSTANTS.Chain.EVM.sepolia.chainId, // Chain ID of Sepolia
  account: account.address, // Ethereum address derived from the private key
  signMessage: async (data: Uint8Array) => {
    const signature = await account.signMessage({
      message: { raw: data }, // Data to be signed
    });
    return hexToBytes(signature); // Convert signature to byte array
  },
};
```

## 3. Initialize Push Chain

Initialize the Push Chain SDK using the signer object. The default environment is `devnet`:

```typescript
const pushChain = await PushChain.initialize(universalSigner);
```

## 4. Recipient Addresses

For this example, we’ll use Ethereum as the sender’s blockchain and Solana as the recipient’s. Here’s how to configure the recipient Solana address:

```typescript
const recipients: UniversalAccount[] = [
  {
    chain: CONSTANTS.Chain.Solana.devnet.name,
    chainId: CONSTANTS.Chain.Solana.devnet.chainId,
    account: 'ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR',
  },
];
```

## 5. Building the Email Payload

Define the email payload to be sent:

```typescript
const email = {
  title: 'Hello from Ethereum!',
  message: 'This is a cross-chain email to Solana.',
};

// Serialize the email payload
const serializedData = new TextEncoder().encode(JSON.stringify(email));
```

## 6. Send Email

Send the serialized data and category (e.g., `MY_EMAIL_APP`) to the recipients:

```typescript
const tx = await pushChain.tx.send(recipients, {
  category: 'MY_EMAIL_APP', // Specify the category of the transaction
  data: serializedData, // Attach the serialized message
});
```

## 7. Fetch Emails

Now, let's fetch all the emails that a particular user has sent and received.

For fetching the emails sent, we use the function `get` function from the `tx` class.

```typescript
const transactionResponse = (await pushChain.tx.get(
  tx.txHash
)) as SimplifiedBlockResponse;

transactionResponse.blocks.map((block: SimplifiedBlockType) => {
  block.transactions.map((t: SimplifiedTxResponse) => {
    const decodedData = new TextDecoder().decode(
      new Uint8Array(Buffer.from(t.txnData as unknown as string, 'hex'))
    );
    const mailTxData = JSON.parse(decodedData) as {
      title: string;
      message: string;
    };
    console.log(mailTxData);
  });
});
```

## Complete Example Code

```typescript
import { PushChain, CONSTANTS } from '@pushprotocol/push-chain';
import { hexToBytes } from 'viem';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';

async function main() {
  const privateKey = generatePrivateKey();
  const account = privateKeyToAccount(privateKey);

  const universalSigner: UniversalSigner = {
    chain: CONSTANTS.Chain.EVM.sepolia.name,
    chainId: CONSTANTS.Chain.EVM.sepolia.chainId,
    account: account.address,
    signMessage: async (data: Uint8Array) => {
      const signature = await account.signMessage({
        message: { raw: data },
      });
      return hexToBytes(signature);
    },
  };

  const pushChain = await PushChain.initialize(universalSigner);

  const recipients: UniversalAccount[] = [
    {
      chain: CONSTANTS.Chain.EVM.sepolia.name,
      chainId: CONSTANTS.Chain.EVM.sepolia.chainId,
      account: 'ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR',
    },
  ];

  const email = {
    title: 'Hello from Ethereum!',
    message: 'This is a cross-chain email to Solana.',
  };

  const serializedData = new TextEncoder().encode(JSON.stringify(email));

  const tx = await pushChain.tx.send(recipients, {
    category: 'MY_EMAIL_APP',
    data: serializedData,
  });

  await new Promise((resolve) => setTimeout(resolve, 3000));

  const transactionResponse = (await pushChain.tx.get(
    tx.txHash
  )) as SimplifiedBlockResponse;

  transactionResponse.blocks.map((block: SimplifiedBlockType) => {
    block.transactions.map((t: SimplifiedTxResponse) => {
      const decodedData = new TextDecoder().decode(
        new Uint8Array(Buffer.from(t.txnData as unknown as string, 'hex'))
      );
      const mailTxData = JSON.parse(decodedData) as {
        title: string;
        message: string;
      };
      console.log(mailTxData);
    });
  });
}

void main();
```

# Conclusion

This tutorial demonstrated how to build a cross-chain email system using the Push Chain SDK, enabling seamless communication between blockchains like Ethereum and Solana. By setting up the SDK, configuring accounts, and signing transactions, you’ve learned how to send and fetch messages securely across chains.

With this foundation, you can explore more use cases for cross-chain messaging and integrate these features into your dApps. Push Chain simplifies creating interoperable Web3 solutions, opening the door to innovative decentralized applications. 

